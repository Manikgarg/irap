#!/bin/bash
VERSION=0.2d
#irap_single_lib -1 fastq_file [-2 fastq_file2] -c conf  [-s strand (first,second,both)]  -m MEM -t threads -i irap_options [-0] [-h]
f1=
f2=
conf=
strand=both
mem=4000000000
threads=1
irap_options="atlas_run=y"
irap_options=
do_stage0=no
do_clean=n
run_faster=n
min_read_size=30
script_parameters=$*
tidy_up_only=n
do_info_only=n
spikein_fasta=
tsfile=

out_dir=out
# files created by irap_single_lib (not by iRAP)
sl_init_files=
# irap configuration file and options to be used to clean up
irap_clean_conf=
# This script will not run with sudo
# http://unix.stackexchange.com/questions/38538/bash-dev-stderr-permission-denied
STDERR=/dev/stderr

declare -i classified_error=0

#################################################################
#
function print_usage {
cat <<EOF
iRAP wrapper to process a single library
Usage: irap_single_lib -1 fastq_file [-2 fastq_file2] -c irap.configuration  [-s strand (first,second,both)] [-p spikein_fasta] [-m MEM] [-t threads] [-i irap_options] [-0] [-h] [-C]

-0  - should be executed once for each
species/genome/annotation to generate the indexes and other files
necessary for the analysis.

-m MEM - value in bytes

-C full clean up when it exits

-T clean up only

-I only run fastq_info
EOF
}


function pinfo { 
    echo "[INFO: $*]"
}

function perror { 
    echo "[ERROR: $*]" >> $STDERR
}

function pwarning { 
    echo "[WARNING: $*]" >> $STDERR
}


function get_fileprefix {
    filename=`basename $1`
    filepref=`echo $filename|sed "s/.fastq.*//"`
    echo $filepref
}


# check paths - paths to the libraries should be relative although it will work
# with full paths
function check_path {

    path=$1
    var_name=$2
    if [ `echo "$1"|cut -b 1` == "/" ]; then
	pwarning "Relative path expected but a full path was  provided ($var_name)."
    fi
}

# two levels - 
# L1: ~1.7K folders
function get_folder {
    filename=`basename $1`
    filepref=`get_fileprefix $1`
    md5=`echo $filename|md5sum`
    fl=`echo $md5|cut -b 1,2`
    echo $fl/$filepref
}

function get_data_dir {
    # lookup in the conf file
    # 
    d=`echo $irap_options|grep "data_dir="`
    if [ "$d-" != "-" ]; then
	d=`echo $irap_options|sed -E "s/.*\s?data_dir=([^\s]+).*/\1/"`
    else
	d=`grep -E "^\s*data_dir=" $conf | cut -f 2 -d\=`
	if [ "$d-" == "-" ]; then
	    # check if it is already defined
	    if [ "$data_dir-" == "-" ]; then
		perror "Unable to find iRAP's data directory"
		exit 1
	    fi
	fi
    fi
    echo $d
}

function get_rs {
    # lookup in the conf file
    # 
    d=`grep -E "^\s*.*_rs=" $1 | cut -f 2 -d\=`
    echo $d
}

function run_AND_timeIt {
    label=$1
    logfile=$2
    shift 2
    datetime=`date "+%F %R"`
    d=`dirname $logfile`
    mkdir -p $d/logs
    sout=$d/logs/$label.out
    serr=$d/logs/$label.err
    #echo `pwd`
    echo "CMD: $*" 
    # Redirect stderr and stdout to a file
# `W'
#     Number of times the process was swapped out of main memory
#`I'
#     Number of file system inputs by the process.
#`O'
#     Number of file system outputs by the process.
    # label\tTime elapsed\tTime leapsed(Seconds)\taximum resident set size\tcommand\t exit status
    # label |Time elapsed |Time elapsed(Seconds)| maximum resident memory |date|command\t | exit status | ....
    /usr/bin/time -o $logfile -a --format "$label\t%E\t%e\t%M\t$datetime\t$*\t%x\t%I\t%O\t%W" bash -c "$*" 2> $serr 
    EXIT_STATUS=$?
    # output stderr
    #cat $sout >/dev/stdout
    cat $serr > /dev/stderr

    if [ $EXIT_STATUS -ne 0 ]; then
	classify_error $label $serr
	exit $EXIT_STATUS
    else
	rm -f $sout $serr
    fi
    #pinfo $EXIT_STATUS
    return $EXIT_STATUS
}

######################################################
# 
function clean_up_init_files  {
    rm -rf $sl_init_files
}

function clean_up_all {

    if [ "$do_clean" == "y" ]; then
	pinfo "Full clean up..."
	set +e
	irap $irap_clean_conf lib_full_clean &> /dev/null
	set -e
	clean_up_init_files
	pinfo "Full clean up...done."
    fi
}

########################################################
# Try to classify errors on each stage
function classify_error {
    perror "LOG files: $2"    
    ${1}_errors $2
    #echo "!!!!!!!!!!!!!!$classified_error<<<<<<<<<<<<<<<<<<<<" > /dev/stderr
    print_classified_error
}

function print_classified_error {

    if [ "$classified_error" == "1" ]; then
	pinfo "Classified error...cleaning up before exiting."
	clean_up_all
    fi   
    perror $errmsg
}

function set_classified_error {
    classified_error=1
    readonly errmsg="$*"
}

function stage0_errors {
    errf=$1
    E=`grep -E "(disk I/O error|Stale|IOError:)" $errf`
    if [ $? -eq 0 ]; then
	set_classified_error "iRAP stage0: I/O error"
    else
	echo "iRAP Stage0: unclassified error"
    fi

}

function fastqInfo_errors {
    errf=$1
    
    e=`grep -E "(ERROR:|error:|Error)" $errf|tail -n 1`
    # Error in the file
    if [ $? -eq 0 ]; then
	msg=`echo "$e" | grep -E "(duplicated|header|truncated|identifier|character|length|unpaired|encoding)"|tail  -n 1|cut -f 2- -d: `
	if [ $? -eq 0 ]; then
	    set_classified_error "FastqInfo: $msg"
	else
	    set_classified_error "FastqInfo: unclassified error - $e"
	fi
    else 
	echo "FastqInfo: unclassified error - $e"
    fi
}

function iRAP-QC_errors {
    errf=$1
    E=`grep "mv: cannot stat.*filter1.stats"  $errf `
    if [ $? -eq 0 ]; then
	set_classified_error "QC: 1 too short reads or below quality threshold"
    else
	E=`grep "mv: cannot stat.*filter2.stats"  $errf `
	if [ $? -eq 0 ]; then
	    set_classified_error "QC: 2 contamination"
	else
	    E=`grep "mv: cannot stat.*filter3.stats"  $errf `
	    if [ $? -eq 0 ]; then
		set_classified_error "QC: 3 reads with uncalled bases discarded"
	    else
		E=`grep "mv: cannot stat.*filter4.stats"  $errf `
		if [ $? -eq 0 ]; then
		    set_classified_error "QC: 4 reads without mates"
		else
		    E=`grep "Aborted.* bowtie" $errf`
		    if [ $? -eq 0 ]; then
			set_classified_error "QC: IO error?"
		    else
			E=`grep "Premature End-Of-File" $errf`
			if [ $? -eq 0 ]; then
			    set_classified_error "QC: 1 no reads pass the quality threshold"
			else
			    E=`grep "gzip: .*.gz: unexpected end of file" $errf`
			    if [ $? -eq 0 ]; then
				set_classified_error "gzip: unexpected end of file"			
			    else
				E=`grep -E "(disk I/O error|Stale|IOError:)" $errf`
				if [ $? -eq 0 ]; then
				    set_classified_error "QC: I/O error"
				else
				    E=`grep "gzip: .*.gz: unexpected end of file" $errf`
				    if [ $? -eq 0 ]; then
					set_classified_error "gzip: unexpected end of file"			
				    else					
					echo "QC: unclassified error"
				    fi
				fi
			    fi
			fi
		    fi
		fi
	    fi
	fi
    fi
}

function iRAP-Mapping_errors {
    errf=$1
    e=`grep "Error occured when reading beginning of SAM/BAM file." $errf`
    if [ $? -eq 0 ]; then
	set_classified_error "iRAP Mapping: no aligned reads in BAM"
    else
	e=`grep -E "bowtie2-align died with signal .* (core dumped)" $errf`
	if [ $? -eq 0 ]; then
	    echo hostname=`hostname`
	    set_classified_error "iRAP Mapping: bowtie2-align  crashed: `hostname`"
	else
	    e=`grep -E "Error running.*tophat_reports" $errf`
	    if [ $? -eq 0 ]; then
		set_classified_error "iRAP Mapping: internal tophat2 error"
	    else
		E=`grep -E "(disk I/O error|Stale|IOError:)" $errf`
		if [ $? -eq 0 ]; then
		    set_classified_error "iRAP Mapping: I/O error"
		else
		    echo "iRAP Mapping: unclassified error"
		fi
	    fi
	fi

    fi
}

function iRAP-Mapping-QC_errors {
    errf=$1

    E=`grep -E "(disk I/O error|Stale|IOError:)" $errf`
    if [ $? -eq 0 ]; then
	set_classified_error "iRAP Mapping QC: I/O error"
    else
	echo "iRAP Mapping QC: unclassified error"
    fi
}

function iRAP-Quant_errors {
    errf=$1
    e=`grep "Error occured when reading beginning of SAM/BAM file." $errf`
    if [ $? -eq 0 ]; then
	set_classified_error "iRAP Quant: no aligned reads in BAM?"
    else
	E=`grep -E "(disk I/O error|Stale|IOError:)" $errf`
	if [ $? -eq 0 ]; then
	    set_classified_error "iRAP Quant: I/O error"
	else	    
	    echo "iRAP Quant: unclassified error"
	fi
    fi
}

function iRAP-CRAM_errors {
    errf=$1
    E=`grep -E "(disk I/O error|Stale|IOError:)" $errf`
    if [ $? -eq 0 ]; then
	set_classified_error "iRAP CRAM: I/O error"
    else
	echo "iRAP CRAM: unclassified error"
    fi  
}

function iRAP-tidyup_errors {
    errf=$1
    echo "iRAP Tidyup: unclassified error"
}

#################################################################
# 
while getopts "1:2:c:s:m:p:t:i:o:h0fCTI"  Option
do
    case $Option in
	0 ) do_stage0="yes";;
        1 ) f1=$OPTARG;;
        2 ) f2=$OPTARG;;
        c ) conf=$OPTARG;;
	C ) do_clean=y;;
	s ) strand=$OPTARG;;
	p ) spikein_fasta=$OPTARG;;
	m ) mem=$OPTARG;;
	o ) out_dir=$OPTARG;;
	t ) threads=$OPTARG;;
	f ) run_faster=y;;
	T ) tidy_up_only=y;do_clean=y;;
	I ) do_info_only=y;;
	i ) irap_options=$OPTARG;;
        h ) print_usage; exit;;
    esac
done

set +e

if [ "$f1-" == "-" ]; then
    perror "ERROR: -1 parameter not provided" 
    print_usage
    exit 1
fi


if [ "$conf-" == "-" ]; then
    perror "ERROR: -c parameter not provided" 
    print_usage
    exit 1
fi


if [ ! -e $conf ] ; then
    perror "File $conf not found"    
    exit 1
fi


if [ "$do_stage0-" == "yes-" ]; then
    pinfo "Running stage0 only"
fi

####################################
DATA_DIR=`get_data_dir`
pinfo "Data dir.=$DATA_DIR"
folder=`get_folder $f1`
TARGET_DIR=$DATA_DIR/raw_data/single_lib/$folder

#################################################################
odir=$PWD/$out_dir/`dirname $f1|cut -f 2- -d /`
fileprefix=`get_fileprefix $f1`
pinfo "Final files will be placed in $odir"
if [ ! -e  $odir ]; then
    mkdir -p $odir
fi


####################################
# tidy up only
if [ "$tidy_up_only" == "y" ]; then
    # delete the files in the TARGET_DIR
    echo rm -rf $DATA_DIR/raw_data/single_lib/$folder
    rm -rf $DATA_DIR/raw_data/single_lib/$folder
    # this should not be here...
    name=`grep "^name=" $conf|cut -f 2 -d=`
    if [ "$name-" ==  "-" ]; then
	name=`grep "^species=" $conf|cut -f 2 -d=`
    fi
    echo toplevel_dir=$name
    if [ -e $name/tophat2 ] ; then
	find $name/tophat2 -type d -name "`basename $folder`" -print -exec rm -f {} \; ;
    fi
    if [ -e $name/star ] ; then
	find $name/star -type d -name "`basename $folder`" -print -exec rm -f {} \; ;
    fi
    exit 0
fi

####################################
# 
# Check if the files exist
if [ ! -e $f1 ] ; then
    perror "File $f1 not found"    
    exit 1
fi

if [ "$f2-" != "-" ] && [ ! -e $f2 ] ; then
    perror "File $f1 not found"    
    exit 1
fi

check_path $f1 "-1"
# FullPath to $f1
fp_f1=`readlink -f $f1`
f1_bn=`basename $f1`
if [ "$f2-" == "-" ]; then
    fp_f2=
else
    fp_f2=`readlink -f $f2`
    f2_bn=`basename $f2`
    check_path $f2 "-2"
fi

is_atlas_run=`grep -c "^atlas_run=" $conf`
name=
if [ "$is_atlas_run-" != "0-" ]; then
    species=`grep "^species=" $conf | head -n 1| cut -f 2 -d=`
    if [ "$species-" == "-" ]; then
	perror "species undefined"
	exit 1
    fi
    name="name=$species"
    irap_options="$irap_options $name"
fi

set -e

##################################################################
# place the tarball in the right folder

mkdir -p $TARGET_DIR
# target should be unique
sl_init_files="$sl_init_files $TARGET_DIR"


##################################################################
# put the fastq files in the "expected" folder
pushd $TARGET_DIR > /dev/null 
pinfo "Unpacking fastq files to $TARGET_DIR"
if [ -e `basename $f1` ]; then
    pwarning "symlink in $TARGET_DIR already exists..."
    if [ "$run_faster-" != "y-" ]; then
	rm -f `basename $f1`    
    fi
fi
if [ ! -e `basename $f1` ]; then
    ln -b -s $fp_f1 `basename $f1`
fi
rp_f1=$folder/$f1_bn
sl_init_files="$sl_init_files $rp_f1"

rp_f2=
if [ "$f2-" != "-" ]; then
    if [ ! -e `basename $f2` ]; then
	ln -b -s $fp_f2 `basename $f2`
    fi
    rp_f2=$folder/$f2_bn
    sl_init_files="$sl_init_files $rp_f2"
fi

pinfo "FASTQ files in place"
popd > /dev/null 

#################################################################
# 
set +e
if [ "-" != "$spikein_fasta-" ]; then
    pinfo "processing -p option"
    if [ -e "$spikein_fasta" ]; then
	tsfile="$DATA_DIR/raw_data/single_lib/`basename $spikein_fasta`"
	if [ -e $tsfile ]; then
	    pwarning "File $tsfile already exists...file not overwritten"
	else
	    cp -v $spikein_fasta $tsfile
	    pinfo "Copied $spikein_fasta to $tsfile"
	fi
	irap_options="$irap_options spikein_fasta=`basename $tsfile`"
    else
	perror "ERROR:: File '$spikein_fasta' not found"
	exit 1
    fi
fi
set -e
#################################################################
# TSV with the time and memory used
time_log_file=$odir/`get_fileprefix $f1`.time
pinfo "Time log file in $time_log_file"
touch $time_log_file

cat <<EOF > $odir/cmd
irap_single_lib $script_parameters
EOF
########
# Check if stage0 is ok
set +e 
irap conf=$conf data_dir=$DATA_DIR  $irap_options max_mem=$mem max_threads=$threads stage0 -n -q
if [ $? !=  0 ]; then
    if [ "$do_stage0-" == "yes-" ]; then
	pinfo "Running iRAP stage0"
	run_AND_timeIt "stage0" $time_log_file irap conf=$conf data_dir=$DATA_DIR    $irap_options max_mem=$mem max_threads=$threads stage0
    else
	perror "ERROR:Stage0: incomplete - use -0 to run stage0"
	exit 1
    fi
fi

if [ "$do_stage0-" == "yes-" ]; then
    pinfo "Stage0 complete."
    exit 0
fi

#################################################################
# run fastq_info on the file
set -e
pinfo "Validating FASTQ files..."
pinfo "FASTQ files: $f1 $f2"
# Move to the raw data top-level folder
pushd $DATA_DIR/raw_data/single_lib/ >/dev/null
do_validation=1
if [ $run_faster == y ] ; then
    if [ -e $folder/$f1_bn.info ]; then
	do_validation=0
    fi
fi
set +e
if [ $do_validation -eq 1 ]; then
    run_AND_timeIt "fastqInfo" $time_log_file "fastq_info.sh  $folder/$f1_bn $rp_f2  > $folder/$f1_bn.info.tmp && mv $folder/$f1_bn.info.tmp $folder/$f1_bn.info"
    if [ $? != 0 ] ; then
	popd
	set_classified_error "FASTQ validation failed"
	clean_up_all
	print_classified_error
	exit 1
    fi
    pinfo "Validation...done."
    libs=`grep -E "^#(se|pe)=" $folder/$f1_bn.info|sed "s/#//"`
    libname=`echo $libs|cut -f 2 -d=`
    libname_noprefix=`echo $libname |sed "s/^l//"`
    # Add strand information
    echo ${libname}_strand=$strand >> $folder/$f1_bn.info
    sed -i -E "s/^#(se|pe)=/\1=/" $folder/$f1_bn.info		
    # RGId=
    echo "${libname}_rgid=" >> $folder/$f1_bn.info		
    echo "${libname}_shl=@CO\tiRAP:$VERSION\n@CO\tid:$libname_noprefix\n@CO\tAnalysis performed by http://www.ebi.ac.uk/about/people/robert-petryszak team at EMBL-EBI" >> $folder/$f1_bn.info		
else 
    pinfo "Validation skipped"
    libs=`grep -E "^(se|pe)=" $folder/$f1_bn.info|sed "s/#//"`
    libname=`echo $libs|cut -f 2 -d=`
    libname_noprefix=`echo $libname |sed "s/^l//"`
    # check if qual encoding is != from 33 and 64 - temporary fix
    qual=`grep  "_qual=" $folder/$f1_bn.info|sed -E "s/^.*_qual=(.*)/\1/"`
    if [ "$qual-" != "33-" ] && [ "$qual-" != "64" ]; then
	rm -f $folder/$f1_bn.info
	perror "Temporary workaround...please rerun to get the correct error."
	exit 2
    fi
fi
pinfo "Lib. details: $DATA_DIR/$folder/$f1_bn.info"

if [ $do_info_only == "y" ]; then
    pinfo "All done"
    exit 0
fi    
popd
INFO_FILE=$TARGET_DIR/$f1_bn.info
sl_init_files="$sl_init_files $INFO_FILE"

set +e

# check the read size
rs=`get_rs $INFO_FILE`
if [ "-" == "$rs-" ] || [ $rs -lt $min_read_size ]; then
    set_classified_error "FastqInfo: Read size smaller than $min_read_size"
    clean_up_all
    print_classified_error
    exit 1
fi
irap_single_lib_options="conf=$conf data_dir=$DATA_DIR $libs lib.info=$INFO_FILE max_mem=$mem max_threads=$threads raw_folder=single_lib "
irap_clean_conf="$irap_single_lib_options $irap_options"

##################################################################
pinfo "QC and filtering..."
run_AND_timeIt "iRAP-QC" $time_log_file  irap $irap_single_lib_options $irap_options stage1
pinfo "QC and filtering...complete."


pinfo "Aligning data..."
run_AND_timeIt "iRAP-Mapping" $time_log_file  irap $irap_single_lib_options $irap_options stage2
pinfo "Aligning data...complete."

pinfo "Quantification..."
run_AND_timeIt "iRAP-Quant" $time_log_file  irap $irap_single_lib_options $irap_options stage3as
pinfo "Quantification...complete."

#################################################################
pinfo "Mapping QC..."
# report files
REPORT_TSVs=`irap $irap_single_lib_options  $irap_options print_mapping_report_req  |tail -n 1 |grep -v "make:"`
if [ "$REPORT_TSVs-" == "-" ]; then
    pinfo "No mapping report"
    run_AND_timeIt "iRAP-Mapping-QC" $time_log_file  echo nothing to do
else
    run_AND_timeIt "iRAP-Mapping-QC" $time_log_file  irap $irap_single_lib_options $irap_options  $REPORT_TSVs
fi
if [ $? != 0 ]; then
    perror "iRAP Mapping QC failed"
    exit 1
fi
pinfo "Mapping QC...complete."


#################################################################
# BAM->CRAM
set -e
BAM=`irap $irap_single_lib_options $irap_options print_stage2_files|tail -n 1|grep -v "make:"`
if [ "$BAM-" == "-" ]; then
    run_AND_timeIt "iRAP-CRAM" $time_log_file  echo no bam no cram
else

    if [ ! -e "$BAM" ]; then
	perror "Ooops: $BAM not found! This is not good."
	exit 1
    fi


CRAM_FILE=`dirname $odir/$f1_bn`/$libname_noprefix.cram    
set +e
if [ $run_faster=="y" ] && [ -e $CRAM_FILE ] && [ -e $CRAM_FILE.md5 ] ; then
    pinfo "$CRAM_FILE exists - skipping generation of CRAM file. Do not use -f option to force the generation of the CRAM file."
else
    # cp while in devel 
    #mv $BAM $odir/$f1_bn.bam
    cp $BAM $odir/$f1_bn.bam
    # add the headers to the BAM
    samtools view -H $odir/$f1_bn.bam > $odir/.header
    
    # create the CRAM file
    pinfo "CRAMMING..."
    run_AND_timeIt "iRAP-CRAM" $time_log_file  irap $irap_single_lib_options $irap_options  $odir/$f1_bn.cram
    if [ $? != 0 ]; then
	perror "Generation of CRAM file failed"
	exit 1
    fi
    pinfo "CRAMMING...done."

    mv $odir/$f1_bn.cram $CRAM_FILE
    pinfo "CRAM_FILE created"
    # generate the md5sum
    md5sum $CRAM_FILE > $CRAM_FILE.tmp.md5 && mv $CRAM_FILE.tmp.md5 $CRAM_FILE.md5
    pinfo "$CRAM_FILE.md5 created"
    rm -f $odir/$f1_bn.bam
    pinfo "Temporary BAM file deleted"
fi
fi
# 
TSVs=`irap $irap_single_lib_options  $irap_options print_stage3_s_targets  |tail -n 1|grep -v "make:"`

pinfo "Moving the following files to $odir: $TSVs $REPORT_TSVs"
cp -a $TSVs $odir
#mv $TSVs $odir

# report files
if [ "$REPORT_TSVs-" != "-"  ]; then 
    cp -a $REPORT_TSVs $odir
fi
# rename the files (remove the l prefix added by fastq_info)
rename $libname $libname_noprefix `dirname $odir/$f1_bn`/$libname*

# copy the info file
cp $INFO_FILE $odir

# QC
echo irap $irap_single_lib_options  $irap_options print_qc_dirs_files 
TSVs=`irap $irap_single_lib_options  $irap_options print_qc_dirs_files  |tail -n 1`
pinfo "Moving the following files to $odir: $TSVs "
mkdir -p $odir/qc
cp -ar $TSVs $odir/qc

# software versions
pinfo "Generating  $odir/versions.tsv..."
irap $irap_single_lib_options  $irap_options $odir/irap.versions.tsv  > $odir/versions.tsv.tmp && mv $odir/versions.tsv.tmp $odir/versions.tsv
pinfo "Generating  $odir/versions.tsv...done"
#################################################################
# Cleanup
if [ "$do_clean" == "y" ]; then
    clean_up_all
else
    run_AND_timeIt "iRAP-tidyup" $time_log_file  irap $irap_single_lib_options $irap_options clean
fi

pinfo "Files in $odir"
pinfo "All done."
exit 0
