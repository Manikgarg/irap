#!/usr/bin/env Rscript3
#; -*- mode: R;-*-
# =========================================================
# Copyright 2012-2014,  Nuno A. Fonseca (nuno dot fonseca at gmail dot com)
#
# This file is part of iRAP.
#
# This is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with iRAP.  If not, see <http://www.gnu.org/licenses/>.
#
#
#    $Id: irap.txt Nuno Fonseca Wed Feb 6 00:51:29 2013$
# =========================================================
suppressPackageStartupMessages(library("optparse"))

IRAP.DIR <- Sys.getenv(c("IRAP_DIR"))
if ( IRAP.DIR == "" ) {
  cat("ERROR: environment variable IRAP_DIR is not set\n")
  q(status=1)
}
# specify our desired options in a list
#
source(paste(IRAP.DIR,"aux/R","irap_utils.R",sep="/"))
pdebug.enabled <- FALSE
html.temp <- get.path2template("mapping_report")

#######################
usage <- "irap_report_mapping --out html_file [options]"
option_list <- list(
  make_option(c("--css"), type="character",default="irap.css",help="Path to the irap.css file relative to the location of the produced html file [default: %default"),
  make_option(c("--debug"),action="store_true",dest="debug",default=FALSE,help="Debug mode"),
  make_option(c("-o","--out"),type="character",default=NULL,help="Output html file"),
  make_option(c("--bam_stats"),type="character",default=NULL,dest="bam_stats",help="Statistics collected from all BAM files"),
  make_option(c("--bam_statsp"),type="character",default=NULL,dest="bam_statsp",help="Statistics collected from all BAM files (%)"),
  make_option(c("-m","--mapper"),type="character",dest="mapper",default=NULL,help="Name of the mapper"),
  make_option(c("--pe"),type="character",dest="pe_bams",default=NULL,help="BAM files generated from paired-end libraries"),
  make_option(c("--se"),type="character",dest="se_bams",default=NULL,help="BAM files generated from single-end libraries"),
  make_option(c("-p","--pe_labels"),type="character",dest="pe_labels",default=NULL,help="Labels for the BAM files generated from paired-end libraries"),
  make_option(c("-s","--se_labels"),type="character",dest="se_labels",default=NULL,help="Labels for the BAM files generated from single-end libraries"),
  make_option(c("-t","--html"),type="character",dest="html_template",default=html.temp,help="HTML template file [default: %default]"),
  make_option(c("-c", "--cores"), type="character",default="3",dest="num_cores",help="Number of cores to use ([default %default])")
)

multiple.options = list()
filenames <- c("html_template","bam_stats","bam_statsp") ;#filenames that must exist (if defined)

# check multiple options values
mandatory <- c("out","bam_stats","mapper","se_bams","pe_bams","se_labels","pe_labels","html_template","bam_statsp")

#
args <- importArgsfromStdin()
opt <- myParseArgs(usage = usage, option_list=option_list,filenames.exist=filenames,multiple.options=multiple.options,mandatory=mandatory,args=args)

irap.css <- opt$css
pdebug.enabled <- opt$debug
pdebug.save.state("irap_report_mapping","p0")

suppressPackageStartupMessages(library(parallel))

tryCatch(num.cores <- as.integer(as.numeric(opt$num_cores)),warning=
         function(w) {
           perror("Invalid number of cores ",opt$num_cores)
           q(status=3)    
       }
)
if (num.cores<1) {
  perror("Invalid number of cores ",opt$num_cores)
  q(status=3)    
}

pinfo("stats=",opt$bam_stats)
pinfo("statsp=",opt$bam_statsp)
pinfo(names(opt))
irap.assert(num.cores>0)

if ( num.cores>parallel:::detectCores()) {
  num.cores <- parallel:::detectCores()
  pwarning("The number of cores to use exceeds the cores available. Reducing the limit to ",parallel:::detectCores())
}

options("cores"=num.cores)


pe.bam.v <- strsplit(gsub(" *; *",";",gsub("^;","",opt$pe_bams)),split="[; ]")[[1]]
se.bam.v <- strsplit(gsub(" *; *",";",gsub("^;","",opt$se_bams)),split="[; ]")[[1]]

pe.labels.v <- strsplit(gsub(" *; *",";",gsub("^;","",opt$pe_labels)),split="[; ]")[[1]]
se.labels.v <- strsplit(gsub(" *; *",";",gsub("^;","",opt$se_labels)),split="[; ]")[[1]]

if (sum(length(pe.bam.v)+length(se.bam.v))==0) {
  perror("At least one bam file needs to be provided.")
  q(status=1)
}

if (length(pe.bam.v)!=length(pe.labels.v)) {
  perror("Number of PE bams and labels differ.")
  q(status=1)
}
if (length(se.bam.v)!=length(se.labels.v)) {
  perror("Number of SE bams and labels differ.")
  q(status=1)
}

pinfo("Parameters parsed.")
pdebug.save.state("irap_report_mapping","p1")

###########################################
# Functions
###########################################
big.dataset <- 2
## mapping.plot(mapping.dfs$raw)
## mapping.plot(mapping.dfs$perc,
##              exclude.cols=c("Median","Mean","SD"),
##              vals=c("Reads mapped","Reads unmapped","Uniquely mapped","Reads spliced"),outlier.vals=c("Reads mapped","Reads unmapped","Uniquely mapped","Reads spliced"),
##              ylab="%",
##              ylim=c(0,100))
## mapping.dfs$perc$SE4=mapping.dfs$perc$SE1
## mapping.dfs$perc$SE5=mapping.dfs$perc$SE1
## mapping.dfs$perc$SE6=mapping.dfs$perc$SE1
## mapping.dfs$perc$SE7=mapping.dfs$perc$SE1
## mapping.dfs$perc$SE8=mapping.dfs$perc$SE1
## mapping.dfs$perc$SE9=mapping.dfs$perc$SE1
## mapping.dfs$perc$SE91=mapping.dfs$perc$SE1
## mapping.dfs$perc$SE92=mapping.dfs$perc$SE1
##mapping.dfs$perc$SE912=mapping.dfs$perc$SE2
##mapping.dfs$perc$SE913=mapping.dfs$perc$SE2
#mapping.dfs$perc$SE914=mapping.dfs$perc$SE2
#mapping.dfs$perc$SE914=mapping.dfs$perc$SE2*0.2
#df <- mapping.dfs$perc
mapping.plot <- function(df,is.small.dataset=FALSE,
                         big.dataset.max.out=30,
                         exclude.cols=NULL,
                         ylab=NULL,
                         ylim=NULL,
                         labels=NULL,
                         cols=NULL,
                         out.beside=TRUE,
                         legend.horiz=NULL,
                         vals=c("Alignments","Reads mapped","Reads unmapped","Uniquely mapped","Reads spliced"),
                         outlier.vals=c("Reads unmapped","Uniquely mapped","Reads spliced")) {

  cex <- 0.85
  df.rows <- vals
  # filter out some cols
  if (!is.null(exclude.cols)) {
    df <- df[,!colnames(df) %in% exclude.cols,drop=FALSE]
  }
  if (is.null(labels)) {
    labels <- vals
  }
  if (is.null(ylab)) {
    ylab <- "Number of Alignments/Reads"
  }
  if ( is.null(cols) ) {
    cols <- rainbow(length(df.rows))
  }
  df <- df[df.rows,]
  if (is.null(ylim) ) {
    ylim <- c(0,max(df,na.rm=T))
  }
  if (!is.small.dataset && ncol(df)>big.dataset) {
    pwarning("Big dataset mode")
    out <- NULL
    if (!is.null(outlier.vals) ) {
      out.sel.df <- df[outlier.vals,,drop=FALSE]
      bp<-boxplot(x=t(out.sel.df),add=F,out=T,names=rownames(out.sel.df),ylim=ylim)
      # find the outliers
      #print(bp)
      min.vals <- bp$stats[5,]
      max.vals <- bp$stats[1,]
      names(min.vals) <- rownames(out.sel.df)
      names(max.vals) <- rownames(out.sel.df)
      out <- c()
      for ( n in names(min.vals)[names(min.vals) %in% rownames(out.sel.df)] ) {
        tmp.out <- colnames(df)[as.matrix(df[n,])<min.vals[n] | as.matrix(df[n,])>max.vals[n]]
        if ( !is.null(tmp.out)) {
          out <- append(out,tmp.out)
        }
      }      
      out <- unique(out)
      #pinfo("out=",out)
      #out.sel.df[,out]
    } 
    # 
    # plot the outliers if any
    par(mar=c(9,6,4,2),bty='n',xpd=NA)
    if ( !is.null(out) ) {
      # no outliers
      w <- max(nrow(df),4)+max(length(out),nrow(df)*2)
      if ( out.beside ) {
        widths <- round(c(max(nrow(df),4)/w*10,max(length(out),nrow(df))/w*10),0)
      } else {
        widths <- round(c(max(nrow(df),4)/w*10,max(length(out),nrow(df))/w*10),0)
      }
      widths <- widths/sum(widths)
      layout(matrix(c(1,2),ncol=2),widths = widths)
      pdebug(widths)
    }
    bp<-boxplot(x=t(df),col=cols,las=2,names=labels,ylim=ylim,add=F,out=T,
                outpch=16)    
    title(ylab=ylab,mgp=c(5,1,0))
    # outliers (detailed)
    if (!is.null(out) ) {
      df <- df[,out[seq(1,min(length(out),big.dataset.max.out))]]
      par(mar=c(3,3,4,2),bty='n',xpd=NA)
      mapping.plot(df,is.small.dataset=T,ylab=ylab,vals=vals,exclude.cols=exclude.cols,labels=labels,cols=cols,out.beside=out.beside,ylim=ylim,legend.horiz)
      do.horiz <- legend.horiz
      if (!is.null(legend.horiz) ) {
        do.horiz <- legend.horiz
        if (nrow(df)<=3) {
          inset <- c(0,-0.15)
        } else {
          inset <- c(-nrow(df)/sqrt(max(length(out),4)),-0.15)
        }
        pwarning("inset=",inset,"...",nrow(df),"...",length(out),"...",sqrt(length(out)))
      } else {
        if ( ncol(df) > 4 ) {
          do.horiz <- T
          inset <- c(-0.2,-0.15)
        } else {        
          do.horiz <- F
          inset <- c(-0.7,-0.15)
        }
      }
      legend("topleft",inset=inset,legend=labels,fill=cols,horiz=do.horiz, cex=cex,bty='n')
    }
  } else {
    par(mar=c(9,5,4,2))
    n <- length(colnames(df))
    width=0.8
    if ( out.beside ) {
      xlim <- c(-0.1,(0.8*nrow(df))*n)

    } else {
      xlim <- NULL
    }
    bp <- barplot(as.matrix(df),
                  las=2,
                  cex.axis=cex,
                  cex.names=cex*0.90,
                  col=cols,
                  beside=out.beside,
                  xaxs="i",
                  width=width,
                  ylim=ylim,
                  xlim=xlim
                  )

    par( xpd=NA )
    if (!is.small.dataset) {
      if (is.null(legend.horiz) ) {
        legend.horiz=F
      }
      legend("top",inset=c(0,-0.05),legend=df.rows,fill=cols,horiz=legend.horiz, cex=0.70,bty='n')
      title(ylab=ylab,mgp=c(4,1,0),main=paste("N=",ncol(df)))
    } else {
      title(ylab=ylab,mgp=c(4,1,0))
    }
  }
}
#big.dataset <- 2
plot.mapping.feat <- function(df,is.small.dataset=FALSE,
                              sel.columns=NULL,cols=NULL,
                              ylab=NULL,
                              big.dataset.max.out=40,ylim=NULL)
{

  cex <- 0.85
                                        # filter out some cols
  if (!is.null(sel.columns)) {
    df <- df[,sel.columns,drop=FALSE]
  }
  if ( is.null(cols) ) {
    cols <- rainbow(length(df.rows))
  }
  if (is.null(ylim) ) {
    ylim <- c(0,max(colSums(df),na.rm=T))
  }
  if ( is.null(ylab) ) {
    ylab=""
  }
  if (!is.small.dataset && ncol(df)>big.dataset) {
    pwarning("Big dataset mode")
    out <- NULL
    out.sel.df <- df
    bp<-boxplot(x=t(out.sel.df),add=F,out=T,names=rownames(out.sel.df),ylim=ylim)
                                        # find the outliers
    min.vals <- bp$stats[5,]
    max.vals <- bp$stats[1,]
    names(min.vals) <- rownames(out.sel.df)
    names(max.vals) <- rownames(out.sel.df)
    out <- c()
    for ( n in names(min.vals)[names(min.vals) %in% rownames(out.sel.df)] ) {
      tmp.out <- colnames(df)[as.matrix(df[n,])<min.vals[n] | as.matrix(df[n,])>max.vals[n]]
      if ( !is.null(tmp.out)) {
        out <- append(out,tmp.out)
      }
    }      
    out <- unique(out)
    #pinfo("out=",out)
    # plot the outliers if any
    par(mar=c(11,6,4,2),bty='n',xpd=NA)
    if ( !is.null(out) ) {
                                        # no outliers
      w <- 5+max(length(out),10)
      widths <- round(c(nrow(df)/w*10,max(length(out),nrow(df))/w*10),0)
      widths <- widths/sum(widths)
      layout(matrix(c(1,2),ncol=2),widths = widths)
      #pinfo(widths)
    }
    bp<-boxplot(x=t(df),col=cols,las=2,names=rownames(df),ylim=ylim,add=F,out=T,
                outpch=16)    
    title(ylab=ylab,mgp=c(5,1,0),main=paste("N=",ncol(df)))
                                        # outliers (detailed)
    if (!is.null(out) ) {
      df <- df[,out[seq(1,min(length(out),big.dataset.max.out))]]
      par(mar=c(3,3,4,2),bty='n',xpd=NA)
      plot.mapping.feat(df,is.small.dataset=T,cols=cols,ylim=ylim,ylab=ylab)
      if ( ncol(df) > 4 ) {
        do.horiz <- T
        inset <- c(-0.2,-0.15)
      } else {
        do.horiz <- F
        inset <- c(-0.7,-0.15)
      }
    }
  } else {
    par(mar=c(9,5,4,11))
    bp <- barplot(as.matrix(df),las=2,
                  beside=F,col=cols,                  
                  horiz=F,cex.axis=0.8,
                  xaxs="i",xlim=c(-0.1,0.1+ncol(df)),
                  ylim=ylim,
                  width=0.8)
    title(ylab=ylab,mgp=c(4,1,0))
    par( xpd=NA )
    legend(ceiling(max(bp)),max(colSums(df,na.rm=T)),legend=pprint.fieldname(rownames(df)),fill=cols,horiz=FALSE, cex=0.70,bty='n')                          
  }
}


##################################################


get.mapping.feature.stats <- function(mapper,pe.bam.v,se.bam.v,pe.labels.v,se.labels) {
  # raw<-mapping.dfs$raw
  libs <- unique(append(pe.labels.v,se.labels.v))
  bams <- append(pe.bam.v,se.bam.v)
  nlibs <- length(libs)
  pinfo("Processing ",nlibs," BAM files")

  bams.stats.files <- paste(bams,".stats",sep="")
  names(bams.stats.files) <- libs
  stats <- list()
  # Check if file exists
  for ( n in names(bams.stats.files) ) {
    f <- bams.stats.files[n]
    pinfo("Loading ",f)
    if ( !is.null(file.required(f,fatal=F)) ) {
      # load file
      x <- load.gff3(f,"gene")
      if ( nrow(x)==0 ) {
        perror("No gene entries found in file",f)
        q(status=1)
      }
      # slice some columns
      type.genes <- x[x$type=="gene",c("source","comments")]
      x <- aggregate(type.genes$comments,list(source=type.genes$source),sum)
      stats[[n]] <- x$x
      names(stats[[n]]) <- x$source
    }
  }
  aln.stats <- do.call("cbind",stats)
  if ( is.null(aln.stats) ) {
    perror("unable to find any .bam.stats file")
    q(status=1)
  }
  if ( ncol(aln.stats)!=nlibs) {
    pwarning("unable to find all .bam.stats file")
  }
  aln.stats.median <- apply(aln.stats,MARGIN=1,FUN=median)
  aln.stats.mean <- apply(aln.stats,MARGIN=1,FUN=mean)
  aln.stats.sd <- apply(aln.stats,MARGIN=1,FUN=sd)
  cols.names <- colnames(aln.stats) 
  aln.stats <- cbind(aln.stats,aln.stats.median,aln.stats.mean,aln.stats.sd)
  colnames(aln.stats) <- append(cols.names,c("Median","Mean","SD"))
  aln.stats <- aln.stats[,append(c("Median","Mean","SD"),cols.names)]
  if ( is.null(dim(aln.stats))) {
    m <- as.data.frame(matrix(aln.stats,nrow=1,ncol=length(aln.stats)))
    #print(aln.stats)
    #print(stats)
    colnames(m) <- names(aln.stats)
    rownames(m) <- names(stats[[1]])
    aln.stats <- m                
  }
  # sort
  if (nrow(aln.stats) >= 2){
    t.order <- names(sort(aln.stats[,"Mean"],decreasing=T))
    aln.stats <- aln.stats[t.order,]  
  }
  return(aln.stats)
}

get.mapping.gene.stats <- function(mapper,pe.bam.v,se.bam.v,pe.labels.v,se.labels) {
  # raw<-mapping.dfs$raw
  libs <- unique(append(pe.labels.v,se.labels.v))
  bams <- append(pe.bam.v,se.bam.v)
  nlibs <- length(libs)
  pinfo("Processing ",nlibs," BAM files")

  bams.stats.files <- paste(bams,".gene.stats",sep="")
  names(bams.stats.files) <- libs
  stats <- list()
  # Check if file exists
  for ( n in names(bams.stats.files) ) {
    f <- bams.stats.files[n]
    if ( !is.null(file.required(f,fatal=F)) ) {
      # load file
      x <- read.tsv(f,header=F)
      names(x$V2) <- x$V1
      if (length(names(stats))==0 ) {
        stats[["feat"]] <- as.character(x$V1)
      }
      stats[[n]] <- x$V2
    }
  }
  gene.stats <- do.call("cbind",stats[-1])
  rownames(gene.stats) <- stats[[1]]
  if ( ncol(gene.stats)!=nlibs) {
    pwarning("unable to find all .bam.gene.stats file")
  }
  #
  gene.stats.median <- apply(gene.stats,MARGIN=1,FUN=median)
  gene.stats.mean <- apply(gene.stats,MARGIN=1,FUN=mean)
  gene.stats.sd <- apply(gene.stats,MARGIN=1,FUN=sd)
  cols.names <- colnames(gene.stats) 
  gene.stats <- cbind(gene.stats,gene.stats.median,gene.stats.mean,gene.stats.sd)
  colnames(gene.stats) <- append(cols.names,c("Median","Mean","SD"))
  gene.stats <- gene.stats[,append(c("Median","Mean","SD"),cols.names)]
  if ( is.null(dim(gene.stats))) {
    m <- as.data.frame(matrix(gene.stats,nrow=1,ncol=length(gene.stats)))
    colnames(m) <- names(gene.stats)
    gene.stats <- m                
  }
  return(gene.stats)
}


# Only report the count of overlaps
# export variables
#opt$mapper_name="tophat1"
mapper <- opt$mapper
mapping.dfs <- list()
mapping.dfs$raw <- quant.load(opt$bam_stats)
mapping.dfs$perc <- quant.load(opt$bam_statsp)
if ( is.null(mapping.dfs$raw) || is.null(mapping.dfs$perc) ) {
  perror("Unable to read '",opt$bam_stats,"' or '",opt$bam_statsp,"'.")
  q(status=1)
}
#rownames(mapping.dfs$perc) <- mapping.dfs$perc[,1]
#mapping.dfs$perc <- mapping.dfs$perc[,-1,drop=FALSE]
mapping.feat <- get.mapping.feature.stats(mapper,pe.bam.v,se.bam.v,pe.labels.v,se.labels.v)
# exons/introns
mapping.genes <- get.mapping.gene.stats(mapper,pe.bam.v,se.bam.v,pe.labels.v,se.labels.v)
pdebug.save.state("irap_report_mapping","p3")
library(brew)
####################################
out.dir <- dirname(opt$out)
out.prefix <- sub(".htm.*","",basename(opt$out))

# save files
raw.stats.file <- paste(out.prefix,"_mapping_stats_raw.tsv",sep="")
r <- write.tsv(mapping.dfs$raw,file=paste(out.dir,"/",raw.stats.file,sep=""),rownames.label="")
pinfo("Saved ",raw.stats.file)

perc.stats.file <- paste(out.prefix,"_mapping_stats_perc.tsv",sep="")
r <- write.tsv(mapping.dfs$perc,file=paste(out.dir,"/",perc.stats.file,sep=""),rownames.label="")
pinfo("Saved ",perc.stats.file)


feat.stats.file <- paste(out.prefix,"_mapping_stats_feat.tsv",sep="")
r <- write.tsv(mapping.feat,file=paste(out.dir,"/",feat.stats.file,sep=""),rownames.label="Features")
pinfo("Saved ",feat.stats.file)

gene.stats.file <- paste(out.prefix,"_mapping_stats_gene.tsv",sep="")
r <- write.tsv(mapping.genes,file=paste(out.dir,"/",gene.stats.file,sep=""),rownames.label="")
pinfo("Saved ",gene.stats.file)

pdebug.save.state("irap_report_mapping","p4")

out.html.file <- paste(opt$out,sep="")
brew.wrapper(opt$html_template,opt$out)
warnings()
q()

IRAP.DIR <- Sys.getenv(c("IRAP_DIR"))
if ( IRAP.DIR == "" ) {
  IRAP.DIR="/home/nf/Research/Projects/WIP/EREAP/irap9"
  Sys.setenv(IRAP_DIR=IRAP.DIR)
}

