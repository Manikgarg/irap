#!/usr/bin/env R3script
# =========================================================
# Copyright 2012-2014,  Nuno A. Fonseca (nuno dot fonseca at gmail dot com)
#
# This file is part of iRAP.
#
# This is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with iRAP.  If not, see <http://www.gnu.org/licenses/>.
#
#
#    $Id: irap.txt Nuno Fonseca Wed Feb 6 00:51:29 2013$
# =========================================================
suppressPackageStartupMessages(library("optparse"))

IRAP.DIR <- Sys.getenv(c("IRAP_DIR"))
if ( IRAP.DIR == "" ) {
  cat("ERROR: environment variable IRAP_DIR is not set\n")
  q(status=1)
}
# specify our desired options in a list
#
source(paste(IRAP.DIR,"aux/R","irap_utils.R",sep="/"))
pdebug.enabled <- FALSE
html.temp <- get.path2template("mapping_report")

#######################
usage <- "irap_report_mapping --out html_file [options]"
option_list <- list(
  make_option(c("--css"), type="character",default="irap.css",help="Path to the irap.css file relative to the location of the produced html file [default: %default"),
  make_option(c("--debug"),action="store_true",dest="debug",default=FALSE,help="Debug mode"),
  make_option(c("-o","--out"),type="character",default=NULL,help="Output html file"),
  make_option(c("-m","--mapper"),type="character",dest="mapper",default=NULL,help="Name of the mapper"),
  make_option(c("--pe"),type="character",dest="pe_bams",default=NULL,help="BAM files generated from paired-end libraries"),
  make_option(c("--se"),type="character",dest="se_bams",default=NULL,help="BAM files generated from single-end libraries"),
  make_option(c("-p","--pe_labels"),type="character",dest="pe_labels",default=NULL,help="Labels for the BAM files generated from paired-end libraries"),
  make_option(c("-s","--se_labels"),type="character",dest="se_labels",default=NULL,help="Labels for the BAM files generated from single-end libraries"),
  make_option(c("-t","--html"),type="character",dest="html_template",default=html.temp,help="HTML template file [default: %default]")
)

multiple.options = list()
filenames <- c("html_template") ;#filenames that must exist (if defined)

# check multiple options values
mandatory <- c("out","mapper","se_bams","pe_bams","se_labels","pe_labels","html_template")
opt <- myParseArgs(usage = usage, option_list=option_list,filenames.exist=filenames,multiple.options=multiple.options,mandatory=mandatory)


irap.css <- opt$css
pdebug.enabled <- opt$debug
pdebug.save.state("irap_report_mapping","p0")

pe.bam.v <- strsplit(gsub(" *; *",";",gsub("^;","",opt$pe_bams)),split="[; ]")[[1]]
se.bam.v <- strsplit(gsub(" *; *",";",gsub("^;","",opt$se_bams)),split="[; ]")[[1]]

pe.labels.v <- strsplit(gsub(" *; *",";",gsub("^;","",opt$pe_labels)),split="[; ]")[[1]]
se.labels.v <- strsplit(gsub(" *; *",";",gsub("^;","",opt$se_labels)),split="[; ]")[[1]]

if (sum(length(pe.bam.v)+length(se.bam.v))==0) {
  perror("At least one bam file needs to be provided.")
  q(status=1)
}

if (length(pe.bam.v)!=length(pe.labels.v)) {
  perror("Number of PE bams and labels differ.")
  q(status=1)
}
if (length(se.bam.v)!=length(se.labels.v)) {
  perror("Number of SE bams and labels differ.")
  q(status=1)
}

pinfo("Parameters parsed.")
pdebug.save.state("irap_report_mapping","p1")
library("emBAM")

###########################################
# Functions
###########################################

mapping.plot <- function(df) {

  df.rows <- c("Alignments","Reads mapped","Unmapped","Uniquely mapped","Spliced reads")
  cols <- rainbow(length(df.rows))
  cex <- 0.85
  
  par(mar=c(9,5,4,2))
  n <- length(colnames(df))
  bp <- barplot(as.matrix(df[df.rows,]),
                las=2,
                cex.axis=cex,
                cex.names=cex*0.90,
                col=cols,
                beside=T,
                xaxs="i",
                width=0.8,
                xlim=c(-0.1,0.1+length(df.rows)*n)
                )
  title(ylab="Number of Alignments/Reads",mgp=c(4,1,0))
  par( xpd=NA )  
  legend("top",inset=c(0,-0.05),legend=df.rows,fill=cols,horiz=TRUE, cex=0.70,bty='n')  
}


mapping.qual <- function(df) {

  df.rows <- c("Alignments (perfect)","Alignments (1-difference)","Alignments (2-difference)","Alignments")
  
  cex <- 0.95
  sliced.df <- data.frame(df[df.rows,])
  rownames(sliced.df) <- df.rows
  colnames(sliced.df) <- colnames(df)
  #sliced.df
  if ( ncol(sliced.df) > 1 ) {
    sliced.df["Alignments",] <- sliced.df["Alignments",]-apply(sliced.df[c("Alignments (perfect)","Alignments (1-difference)","Alignments (2-difference)"),],2,sum)
  } else {
    sliced.df["Alignments",1] <- sliced.df["Alignments",1]-sum(sliced.df[c("Alignments (perfect)","Alignments (1-difference)","Alignments (2-difference)"),1])
  }
  rownames(sliced.df)[4] <- "Alignments (>2-differences)"

  n <- length(colnames(sliced.df))
  cols <- topo.colors(length(df.rows))
  cex <- 0.85
  par(mar=c(9,5,4,2))
  bp <- barplot(as.matrix(sliced.df),
                las=2,
                cex.axis=cex,
                cex.names=cex*0.90,
                col=cols,
                beside=T,
                xaxs="i",
                width=0.8,
                xlim=c(-0.1,0.1+length(df.rows)*n))

  title(ylab="Number of Alignments",mgp=c(4,1,0))
  par( xpd=NA )
  legend("top",inset=c(0,-0.05),legend=gsub("\\)","",gsub("Alignments \\(","",rownames(sliced.df))),fill=cols,horiz=TRUE, cex=0.70,bty='n')  
}



##################################################
get.mapping.stats <- function(mapper,pe.bam.v,se.bam.v,pe.labels.v,se.labels.v) {

  libs <- unique(append(pe.labels.v,se.labels.v))
  nlibs <- length(libs)
  pinfo("Processing ",nlibs," BAM files")
  
  # an individual report for each bam file is available in bam  
  dir.prefix <- paste(mapper,sep="/")
  pe.bam.urls <- c()
  se.bam.urls <- c()
  if (length(pe.labels.v)>0) { pe.bam.urls <- paste("<a href='",dir.prefix,"/",pe.labels.v,"/index.html'>Align. Details</a>",sep="") }
  if (length(se.labels.v)>0) { se.bam.urls <- paste("<a href='",dir.prefix,"/",se.labels.v,"/index.html'>Align. Details</a>",sep="") }

  urls <- append(pe.bam.urls,se.bam.urls)

  m <- matrix(c(urls),nrow=1,byrow=T)
  colnames(m) <- libs

  bam.files <- append(pe.bam.v,se.bam.v)
  #print(bam.files)
  #cat("--------------------------------------------")
  data <- lapply(bam.files,em.bam.counts.df,use.cache=TRUE)
  
  # listOflists2matrix only takes the first column
  #df <- as.data.frame(listOflists2matrix(data))
  #df <- df[c(1:length(data[[1]]$Count)),]
  df <- data.frame(data[[1]][,1])
  rownames(df)<-rownames(data[[1]])
  colnames(df) <- libs[1]
  pinfo("length:",length(data))
  df
  if(length(data)>1) {
    for (i in c(2:length(data))) {
      df <- cbind(df,data[[i]]$Count)
    }
  }
  colnames(df) <- append(pe.labels.v,se.labels.v)
  
  irap.assert(sum(df[,1]!=data[[1]]$Count,na.rm=T)==0)

  #print(df)
  # slice some rows
  sliced.data <- as.data.frame(df[c("Alignments","Primary","Unmapped","Uniquely mapped reads","Multimap reads","Spliced reads","Not primary","Alignments (perfect)","Alignments (1-difference)","Alignments (2-difference)"),])
  rownames(sliced.data) <- c("Alignments","Reads mapped","Unmapped","Uniquely mapped","Multimap reads","Spliced reads","Multimaps","Alignments (perfect)","Alignments (1-difference)","Alignments (2-difference)")
  sel.rows <- c("Alignments","Reads mapped","Unmapped","Uniquely mapped","Multimap reads","Spliced reads","Alignments (perfect)","Alignments (1-difference)","Alignments (2-difference)")
  sliced.data <- data.frame(sliced.data[sel.rows,])
  rownames(sliced.data) <- sel.rows
  colnames(sliced.data) <- colnames(df)
  #df
  sliced.data
  # compute the percentages
  if ( ncol(sliced.data) == 1 ) {
    tot.reads <- sum(sliced.data[c("Reads mapped","Unmapped"),])
    p.sliced.data <- data.frame(sliced.data[c("Reads mapped","Unmapped","Uniquely mapped","Multimap reads","Spliced reads","Alignments (perfect)","Alignments (1-difference)","Alignments (2-difference)"),])
    rownames(p.sliced.data) <- c("Reads mapped","Unmapped","Uniquely mapped","Multimap reads","Spliced reads","Alignments (perfect)","Alignments (1-difference)","Alignments (2-difference)")
    p.sliced.data
  } else {
    tot.reads <- apply(sliced.data[c("Reads mapped","Unmapped"),],MARGIN=2,FUN=sum)
    p.sliced.data <- sliced.data[c("Reads mapped","Unmapped","Uniquely mapped","Multimap reads","Spliced reads","Alignments (perfect)","Alignments (1-difference)","Alignments (2-difference)"),]
  }


  reads.mapped <- as.numeric(sliced.data["Reads mapped",])
  reads.unmapped <- as.numeric(sliced.data["Unmapped",])
  num.alignments <- as.numeric(sliced.data["Alignments",])
  p.sliced.data["Reads mapped",] <- round(reads.mapped/tot.reads*100,2)
  p.sliced.data["Unmapped",] <- round(reads.unmapped/tot.reads*100,2)
  p.sliced.data["Uniquely mapped",] <- round(as.numeric(sliced.data["Uniquely mapped",])/reads.mapped*100,2)
  p.sliced.data["Multimap reads",] <- round(as.numeric(sliced.data["Multimap reads",])/reads.mapped*100,2)
  p.sliced.data["Spliced",] <- round(as.numeric(sliced.data["Spliced",])/reads.mapped*100,2)
  p.sliced.data["Spliced reads",] <- round(as.numeric(sliced.data["Spliced reads",])/reads.mapped*100,2)
  p.sliced.data["Alignments (perfect)",] <- round(as.numeric(sliced.data["Alignments (perfect)",])/num.alignments*100,2)
  p.sliced.data["Alignments (1-difference)",] <- round(as.numeric(sliced.data["Alignments (1-difference)",])/num.alignments*100,2)
  p.sliced.data["Alignments (2-difference)",] <- round(as.numeric(sliced.data["Alignments (2-difference)",])/num.alignments*100,2)
  p.sliced.data["Multimaps",] <- round(as.numeric(sliced.data["Multimaps",])/num.alignments*100,2)
  
  # average
  p.sliced.data.median <- apply(p.sliced.data,MARGIN=1,FUN=median)
  p.sliced.data.mean <- apply(p.sliced.data,MARGIN=1,FUN=mean)
  p.sliced.data.sd <- apply(p.sliced.data,MARGIN=1,FUN=sd)
  #median(as.numeric(p.sliced.data[1,]))
  p.sliced.data <- cbind(p.sliced.data,p.sliced.data.median,p.sliced.data.mean,p.sliced.data.sd)
  colnames(p.sliced.data) <- append(colnames(sliced.data),c("Median","Mean","SD"))
  p.sliced.data <- p.sliced.data[,append(c("Median","Mean","SD"),colnames(sliced.data))]

  return(list(perc=p.sliced.data,raw=sliced.data))
}

get.mapping.feature.stats <- function(mapper,pe.bam.v,se.bam.v,pe.labels.v,se.labels) {
  # raw<-mapping.dfs$raw
  libs <- unique(append(pe.labels.v,se.labels.v))
  bams <- append(pe.bam.v,se.bam.v)
  nlibs <- length(libs)
  pinfo("Processing ",nlibs," BAM files")

  bams.stats.files <- paste(bams,".stats",sep="")
  names(bams.stats.files) <- libs
  stats <- list()
  # Check if file exists
  for ( n in names(bams.stats.files) ) {
    f <- bams.stats.files[n]
    pinfo(f)
    if ( !is.null(file.required(f,fatal=F)) ) {
      # load file
      x <- load.gff3(f,"gene")
      # slice some columns
      type.genes <- x[x$type=="gene",c("source","comments")]
      x <- aggregate(type.genes$comments,list(source=type.genes$source),sum)
      stats[[n]] <- x$x
      names(stats[[n]]) <- x$source
    }
  }
  aln.stats <- do.call("cbind",stats)
  if ( ncol(aln.stats)!=nlibs) {
    pwarning("unable to find all .bam.stats file")
  }
  aln.stats.median <- apply(aln.stats,MARGIN=1,FUN=median)
  aln.stats.mean <- apply(aln.stats,MARGIN=1,FUN=mean)
  aln.stats.sd <- apply(aln.stats,MARGIN=1,FUN=sd)
  cols.names <- colnames(aln.stats) 
  aln.stats <- cbind(aln.stats,aln.stats.median,aln.stats.mean,aln.stats.sd)
  colnames(aln.stats) <- append(cols.names,c("Median","Mean","SD"))
  aln.stats <- aln.stats[,append(c("Median","Mean","SD"),cols.names)]
  # sort
  t.order <- names(sort(aln.stats[,"Mean"],decreasing=T))
  aln.stats <- aln.stats[t.order,]  

  return(aln.stats)
}

get.mapping.gene.stats <- function(mapper,pe.bam.v,se.bam.v,pe.labels.v,se.labels) {
  # raw<-mapping.dfs$raw
  libs <- unique(append(pe.labels.v,se.labels.v))
  bams <- append(pe.bam.v,se.bam.v)
  nlibs <- length(libs)
  pinfo("Processing ",nlibs," BAM files")

  bams.stats.files <- paste(bams,".gene.stats",sep="")
  names(bams.stats.files) <- libs
  stats <- list()
  # Check if file exists
  for ( n in names(bams.stats.files) ) {
    f <- bams.stats.files[n]
    if ( !is.null(file.required(f,fatal=F)) ) {
      # load file
      x <- read.tsv(f,header=F)
      names(x$V2) <- x$V1
      if (length(names(stats))==0 ) {
        stats[["feat"]] <- as.character(x$V1)
      }
      stats[[n]] <- x$V2
    }
  }
  gene.stats <- do.call("cbind",stats[-1])
  rownames(gene.stats) <- stats[[1]]
  if ( ncol(gene.stats)!=nlibs) {
    pwarning("unable to find all .bam.gene.stats file")
  }
  #
  gene.stats.median <- apply(gene.stats,MARGIN=1,FUN=median)
  gene.stats.mean <- apply(gene.stats,MARGIN=1,FUN=mean)
  gene.stats.sd <- apply(gene.stats,MARGIN=1,FUN=sd)
  cols.names <- colnames(gene.stats) 
  gene.stats <- cbind(gene.stats,gene.stats.median,gene.stats.mean,gene.stats.sd)
  colnames(gene.stats) <- append(cols.names,c("Median","Mean","SD"))
  gene.stats <- gene.stats[,append(c("Median","Mean","SD"),cols.names)]
  return(gene.stats)
}


# Only report the count of overlaps
# export variables
#opt$mapper_name="tophat1"
mapper <- opt$mapper
mapping.dfs <- get.mapping.stats(mapper,pe.bam.v,se.bam.v,pe.labels.v,se.labels.v)
mapping.feat <- get.mapping.feature.stats(mapper,pe.bam.v,se.bam.v,pe.labels.v,se.labels.v)
mapping.genes <- get.mapping.gene.stats(mapper,pe.bam.v,se.bam.v,pe.labels.v,se.labels.v)
pdebug.save.state("irap_report_mapping","p3")
library(brew)
####################################
out.dir <- dirname(opt$out)
out.prefix <- sub(".htm.*","",basename(opt$out))

# save files
raw.stats.file <- paste(out.prefix,"_mapping_stats_raw.tsv",sep="")
r <- write.tsv(mapping.dfs$raw,file=paste(out.dir,"/",raw.stats.file,sep=""),rownames.label="")
pinfo("Saved ",raw.stats.file)

perc.stats.file <- paste(out.prefix,"_mapping_stats_perc.tsv",sep="")
r <- write.tsv(mapping.dfs$perc,file=paste(out.dir,"/",perc.stats.file,sep=""),rownames.label="")
pinfo("Saved ",perc.stats.file)

feat.stats.file <- paste(out.prefix,"_mapping_stats_feat.tsv",sep="")
r <- write.tsv(mapping.feat,file=paste(out.dir,"/",feat.stats.file,sep=""),rownames.label="Features")
pinfo("Saved ",feat.stats.file)

gene.stats.file <- paste(out.prefix,"_mapping_stats_gene.tsv",sep="")
r <- write.tsv(mapping.genes,file=paste(out.dir,"/",gene.stats.file,sep=""),rownames.label="")
pinfo("Saved ",gene.stats.file)

pdebug.save.state("irap_report_mapping","p4")

out.html.file <- paste(opt$out,sep="")
brew.wrapper(opt$html_template,opt$out)
warnings()
q()

IRAP.DIR <- Sys.getenv(c("IRAP_DIR"))
if ( IRAP.DIR == "" ) {
  IRAP.DIR="/home/nf/Research/Projects/WIP/EREAP/irap9"
  Sys.setenv(IRAP_DIR=IRAP.DIR)
}

