#!/usr/bin/env Rscript3
# =========================================================
#
# This file is part of iRAP.
#
# This is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with iRAP.  If not, see <http://www.gnu.org/licenses/>.
#
#
# =========================================================
# generate one HTML page with QC report
###########################################################
suppressPackageStartupMessages(library("optparse"))

#
IRAP.DIR <- Sys.getenv(c("IRAP_DIR"))
if ( IRAP.DIR == "" ) {
  cat("ERROR: environment variable IRAP_DIR is not set\n")
  q(status=1)
}
#
source(paste(IRAP.DIR,"aux/R","irap_utils.R",sep="/"))
pdebug.enabled <- FALSE
html.temp <- get.path2template("qc_report")
#######################
usage <- "irap_report_qc --conf conf.file [options]"
option_list <- list(
  make_option(c("-c", "--conf"), type="character",dest="conf.file",help="iRAP's experiment configuration file"),
  make_option(c("--css"), type="character",default="irap.css",help="Path to the irap.css file relative to the location of the produced html file [default: %default"),
  make_option(c("-r", "--rep_dir"), type="character", dest="rep_dir",help="path to iRAP's report directory (output)"),
  make_option(c("--debug"),action="store_true",dest="debug",default=FALSE,help="Debug mode"),
  make_option(c("-t","--html"),type="character",dest="html_template",default=html.temp,help="HTML template file [default: %default]")
)

multiple.options = list()
filenames <- c("conf.file","html_template") ;#filenames that must exist (if defined)

# check multiple options values
mandatory <- c("conf.file","rep_dir","html_template")
opt <- myParseArgs(usage = usage, option_list=option_list,filenames.exist=filenames,multiple.options=multiple.options,mandatory=mandatory)

irap.css <- opt$css

pdebug.enabled <- opt$debug
pinfo("Parameters parsed.")

###########################
# Functions
###########################


totnumreads2filtered <- function(v) {
  # TODO: validate v
  v2 <- v
  v2[1,2] <- v[1,2]-v[1,3]
  v2[1,3] <- v[1,3]-v[1,4]
  v2[1,4] <- v[1,4]-v[1,5]
  v2[1,5] <- v[1,5]-v[1,6]
  v2
}

# average base quality (med col)-> take the mean/median
# gc/content?
# file in the data directory .stats
# number of reads (last column)
# file generated by fastx_nucleotide_distribution_graph.sh (part of FASTX)
stats.file2df <- function(file) {
  #pinfo(file)
  
  if ( file.exists(file) &&  file.info(file)[1]>0 ) {
    data <- read.tsv(file,header=T)
    nreads <- median(data$Max_count)
    mean.base.qual <- mean(data$mean)
    sd.base.qual <- sd(data$mean)
    median.base.qual <- median(data$mean)
    gc <- sum(data$G_Count*1.0)+sum(data$C_Count*1.0)
    at <- sum(data$A_Count*1.0)+sum(data$T_Count*1.0)
    gc.perc <- round(gc/(gc+at)*100,2)
    v <- round(c(nreads,mean.base.qual,sd.base.qual,median.base.qual,gc.perc),2)
  } else {
    pwarning("Empty or missing file ",file)
    v <- c(NA,NA,NA,NA,NA)
  }
  names(v) <- c("reads","mean.base.qual","sd.base.qual","median.base.qual","GC")
  return(v)
}

#
# bam files
bam2fastq_files <- function(files,is.pe=FALSE) {

  if ( length(grep(".bam$",files)) > 0 ) {
    pinfo("Handling bam file...",files)
    files <- sub(".bam$","",files)
    if ( is.pe ) {
      files <- c(paste(files[1],"_1.f",sep=""),paste(files[1],"_2.f",sep=""))
    } else {
      files <- paste(files,".f",sep="")
    }
  }
  return(files)
}

# 
raw.summary.dataframe <- function(conf) {
  filt_stats <- matrix(ncol=17,nrow=0, dimnames = list(NULL,c("Lib","File", "length","qual","strand","ins","sd", "Quality","Contamination","Ns","Unpaired","Passed","reads","mean.base.qual","sd.base.qual","median.base.qual","GC")))
  toplevel.dir <- conf.get.value(conf,"toplevel.dir")
  pe <- conf.get.value(conf,"pe")
  se <- conf.get.value(conf,"se")
  toplevel.dir <- conf.get.value(conf,"toplevel.dir")
  qc.enabled <- conf.is.qc.enabled(conf)

  get.lib.info <- function(df,libs,toplevel.dir,conf,is.pe=TRUE) {
    #libs <- se
    #is.pe=FALSE
    #lib <- libs[1] 
    i <- nrow(df)+1
    for (lib in libs ) {
      linfo <- as.numeric(c(conf.get.value(conf,paste(lib,"_rs",sep="")),
                            conf.get.value(conf,paste(lib,"_qual",sep="")),
                            conf.get.value(conf,paste(lib,"_strand",sep="")),
                            conf.get.value(conf,paste(lib,"_ins",sep="")),
                            conf.get.value(conf,paste(lib,"_sd",sep=""))
                            ))
      if ( !is.pe ) { linfo <- append(linfo,c(NA,NA)) }
      files <- strsplit(as.character(conf.get.value(conf,lib))," ")
      files <- sub("(.gz|.bzip2)","",sub("(.fastq|.fq)",".f",files,ignore.case =TRUE),ignore.case=TRUE,perl=TRUE)
      # BAM support (specific:()
      if ( length(grep(".bam$",files)) > 0 ) {
        pinfo("Handling bam file...",files)
        files <- bam2fastq_files(files,is.pe)
      }   

      if (!is.pe) {
        # SE
        files.f <- paste(lib,".f.fastq",sep="")
      } else {
        # PE
        files.f <- c(paste(lib,"_1.f.fastq",sep=""),paste(lib,"_2.f.fastq",sep=""))
      }
      l.dir <- conf.get.value(conf,paste(lib,"_dir",sep=""))

      if ( !is.null(l.dir) ) {
        #
        l.dir <- sub("/$","",l.dir)
        files.f <- paste(l.dir,files.f,sep="/")
        files <- paste(l.dir,files,sep="/")
      }
      if ( conf.is.qc.enabled(conf) ) { 
        d <- totnumreads2filtered(read.csv(file.required(paste(toplevel.dir,"/report/riq/",files[1],".csv",sep="")),header=FALSE))
        d2 <- stats.file2df(paste(toplevel.dir,"/data/",files.f[1],".stats",sep=""))
        #pinfo(paste(toplevel.dir,"/data/",files.f[1],".stats",sep=""))
        #pinfo(paste(toplevel.dir,"/report/riq/",files[1],".csv",sep=""))
        lib.stats1 <- append(d[1,2:6],d2)
        if (is.pe) {
          d <- totnumreads2filtered(read.csv(file.required(paste(toplevel.dir,"/report/riq/",files[2],".csv",sep="")),header=FALSE))
          d2 <- stats.file2df(paste(toplevel.dir,"/data/",files.f[2],".stats",sep=""))

          lib.stats2 <- append(d[1,2:6],d2)
          #pinfo("PE2:",lib.stats2)
        }
      } else {
        # qc disabled
        lib.stats1 <- c(NA,NA,NA,NA,NA)
        lib.stats2 <- c(NA,NA,NA,NA,NA)
        d2 <- stats.file2df(paste(toplevel.dir,"/data/",files.f[1],".stats",sep=""))
        lib.stats1 <- append(lib.stats1,d2)
        if (is.pe) {
          d2 <- stats.file2df(paste(toplevel.dir,"/data/",files.f[2],".stats",sep=""))
          lib.stats2 <- append(lib.stats2,d2)
        }
      }
      # Add to data frame
      if( is.pe) {
        # use / because some files use a _ or other characters in the filename
        df[i,] <- append(append(c(paste(lib,"/1",sep=""),files[1]),linfo),lib.stats1)
        df[i+1,] <- append(append(c(paste(lib,"/2",sep=""),files[2]),linfo),lib.stats2)
        i <- i+2
      } else {
        df[i,] <- append(append(c(lib,files[1]),linfo),lib.stats1)
        i <- i+1
      }
    }
    return(df)
  }
  df <- data.frame(filt_stats)
  df <- get.lib.info(df,se,toplevel.dir,conf,is.pe=FALSE)
  df <- get.lib.info(df,pe,toplevel.dir,conf,is.pe=TRUE)
  rownames(df) <- df$Lib
  return(df)
}

gen.qc.plot <- function(df) {
  ########################
  # Plot 
  legend <- c("Passed", "Unpaired", "Ns", "Contamination","Quality")
  cols <- c("green","yellow","purple","blue","red")
                                        #rainbow(length(legend))
  bp.data <- t(as.matrix(df[,legend]))
  colnames(bp.data) <- as.character(as.character(df[,c("Lib")]))
  rownames(bp.data) <- legend
  n <- length(colnames(bp.data))
  cex <- NULL
  if ( n>10 ) { cex <- 0.5 } else { cex=0.8}
  par( xpd=NA , mar=c(9,6,4,2))
  #bp <- barplot( bp.data, beside = FALSE, col=cols, las=2 , cex.axis=cex, cex.names=0.8)
  bp <- barplot( bp.data, beside = FALSE, col=cols,  las=2 , cex.axis=cex, cex.names=0.8, xaxs="i",xlim=c(-0.2,0.2+n),width=0.8)
  par( xpd=NA , mar=c(9,6,4,2))
  title(ylab="Number of reads",mgp=c(5,1,0))
  legend("top",inset=c(0,-0.10),legend=legend,fill=cols,horiz=TRUE, cex=0.70,bty='n')                          
  #legend( "bottomleft", legend=legend, fill=cols,horiz=TRUE, cex=0.7, bg="white")
  for( i in c(1:length(colnames(bp.data))) ) {
    total <- sum(bp.data[,i])
    f <- c()
    y <- c()
    f[1] <- round(bp.data[1,i]*100/total)
    y[1] <- bp.data[1,i]
    f[2] <- round(bp.data[2,i]*100/total)
    y[2] <- sum(bp.data[c(1:2),i])  
    f[3] <- round(bp.data[3,i]*100/total)
    y[3] <- sum(bp.data[c(1:3),i])
    f[4] <- round(bp.data[4,i]*100/total)
    y[4] <- sum(bp.data[c(1:4),i])
    f[5] <- round(bp.data[5,i]*100/total)
    y[5] <- sum(bp.data[c(1:5),i])
    for( r in c(1:5) ){
      #pinfo(f[r])
      if (f[r]>2) {
        #
        #legend( bp[i], y[r]-bp.data[r,i]/2, paste("~",f[r], "%", sep=""), bty="n", xjust=0.5, yjust=0.5)
        #pinfo(bp[i]," ",y[r]--bp.data[r,i]/2)
        text( bp[i], y[r]-bp.data[r,i]/2, paste("",f[r], "%", sep=""),cex=cex,las=2,col="black",srt=90)      
      }
    }
  }
  bp
}
# add median, sd columns to the table (it is only applicable to some rows)
qc.expand.table <- function(dft,conf) {
  #dft <- t(df)
  ############################################################
  # generate the matrix/table with the links to fastqc reports  
  dir.name <- paste(conf.get.value(conf,"report.dir"),"riq/",sep="")
  # add a column with the median
  dft.median <- rep("",nrow(dft))
  dft.sd <- rep("",nrow(dft))
  dft.mean <- rep("",nrow(dft))
  names(dft.median) <- rownames(dft)
  names(dft.mean) <- rownames(dft)
  names(dft.sd) <- rownames(dft)

  for ( n in c("Passed","Unpaired","Ns","Contamination","Quality","reads","length","mean.base.qual","sd.base.qual","median.base.qual","GC") ) {
    dft.median[n] <- round(median(as.numeric(dft[n,])),2)
    dft.mean[n] <- round(mean(as.numeric(dft[n,])),2)
    dft.sd[n] <- round(sd(as.numeric(dft[n,])),2)
  }
  dft.nlibs <- ncol(dft)
  dft <- cbind(dft,dft.median,dft.mean,dft.sd)
  colnames(dft)[dft.nlibs+1] <- "Median"
  colnames(dft)[dft.nlibs+2] <- "Mean"
  colnames(dft)[dft.nlibs+3] <- "SD"
  # reorder
  dft <- dft[,c("Median","Mean","SD",colnames(dft)[seq(1,dft.nlibs)])]
  colnames(dft)
  return(dft)
}

quality.details.matrix <- function(bp.data,conf) {
  # DIRECTORIES
  # $dir.name/riq/            - filtered data
  # $dir.name/riq/raw_data    - raw/unfiltered data
  dir.name <- paste(conf.get.value(conf,"report.dir"),"riq/",sep="")
  # each column should correspond to a lib should be 
  data <- bp.data
  # extra row
  data<-rbind(data,rep("",ncol(data)))
  rownames(data)[length(rownames(data))]<-"Initial data (quality report)"
  # another row with the links for the qual plots
  data<-rbind(data,rep("",ncol(data)))
  rownames(data)[length(rownames(data))]<-"Quality plots"
  id <- 1
  pe <- append(sub("$","/1",conf.get.value(conf,"pe")),
               sub("$","/2",conf.get.value(conf,"pe")))
  se <- conf.get.value(conf,"se")
  libs <- append(se,pe)
  #print(bp.data)
  for ( lib in libs ) {
    lib <- mytrim(lib)
    # Handle the special case (filename) of Paired-end libraries
    if (lib %in% pe) {
      #pinfo("PE:",lib)
      lib.id <- as.numeric(sub(".*/","",lib))
      l.dir <- conf.get.value(conf,paste(get.libname(lib),"_dir",sep=""))
      if ( !is.null(l.dir) ) {
        dir.name2 <- paste(dir.name,l.dir,"/",sep="/")
      } else {
        dir.name2 <- dir.name
      }

      filtered.file <- paste(libname2filename(lib),".f",sep="")      
      # s<-lib
      raw.files <- conf.get.value(conf,get.libname(lib))
      # BAM support (specific:()
      if ( length(grep(".bam$",raw.files)) > 0 ) {
        pinfo("Handling bam file...",raw.files)
        raw.files <- sub(".f","",bam2fastq_files(raw.files,is.pe=TRUE))[lib.id]
      } else {
        raw.files <- raw.files[lib.id]
      }
      #pinfo("Raw files:",raw.files)
      #pinfo("Lib id:",lib.id)
      #pinfo("filt files:",filtered.file)      
      files.unfilt <- path2qual.report(paste(dir.name2,"raw_data/",sep=""),sub("^.*/","",sub(".(fastq|fq).*$","",raw.files)))
    } else {
      l.dir <- conf.get.value(conf,paste(lib,"_dir",sep=""))
      if ( !is.null(l.dir) ) {
        dir.name2 <- paste(dir.name,l.dir,"/",sep="/")
      } else {
        dir.name2 <- dir.name
      }
      
      #pinfo("SE:",lib)
      filtered.file <- paste(lib,".f",sep="")
      raw.files <- conf.get.value(conf,get.libname(lib))
      # BAM support (specific:()
      if ( length(grep(".bam$",raw.files)) > 0 ) {
        pinfo("Handling bam file...",raw.files)
        raw.files <- sub(".f","",bam2fastq_files(raw.files,is.pe=FALSE))
      }   
      files.unfilt <- path2qual.report(paste(dir.name2,"raw_data/",sep=""),sub("^.*/","",sub(".(fastq|fq).*$","",raw.files)))
      
    }
    #
    #trace(path2qual.report)
    #debug(path2qual.report)
    files.filt   <- path2qual.report(paste(dir.name2,"raw_data/",sep=""),filtered.file)
    # add a link to the the detailed report
    data["Passed",lib] <- paste(data["Passed",lib]," <a class='download' href='",files.filt["index"],"' target='_top'>QR</a>",sep="")
    data["Initial data (quality report)",lib] <- paste("<a class='download' href='",files.unfilt["index"],"' target='_top'>QR</a>",sep="")
    # Add a div to show the plots before and after filtering
    width <- 450
    visible.text <- "+"
    hidden.text <- paste("<table class='plots' style='text-align: center'><tr><td>Raw data</td><td>Filtered</td></tr>",
                   "<tr><td><img  width='",width,"' src='",files.unfilt["seq.quality"],"' alt='Quality plot'></td><td><img  width='",width,"' src='",files.filt["seq.quality"],"' alt='Quality plot'></td></tr>",
                   "<tr><td><img width='",width,"' src='",files.unfilt["base.quality"],"' alt='Per base quality plot'></td><td><img width='",width,"' src='",files.filt["base.quality"],"' alt='Per base quality plot'></td></tr>",
                   "</table>",sep="")
    
    html  <- HTML.toogle.div(visible.text,hidden.text)
    
    data["Quality plots",lib] <- html
    
    id <- id+1
  }
  data
}

path2qual.report <- function(dir.name,file.prefix) {
  root.dir <- dir.name
  #print(root.dir)
  #print(file.prefix)
  #pinfo(">>>>>",dir.name,"----",file.prefix)
  filt.qual.dir <- paste(root.dir,file.prefix,"_fastqc/",sep="")
  filt.qual.zip <- paste(root.dir,file.prefix,".fastqc.zip",sep="")
  filt.qual.index <- paste(filt.qual.dir,"fastqc_report.html",sep="")
  filt.qual.plot.base.quality <- paste(filt.qual.dir,"Images/per_base_quality.png",sep="")
  filt.qual.plot.seq.quality<- paste(filt.qual.dir,"Images/per_sequence_quality.png",sep="")
  # check if dir exists
  if (!file.exists(filt.qual.dir)) {
    pinfo("Report directory ",filt.qual.dir," not found. Looking for zip file...")
    if (!file.exists(filt.qual.zip)) {
      pmissing(filt.qual.zip)
      return(NULL)
    }
    # unzip file
    unzip.cmd <- paste("unzip -d ",root.dir," ",filt.qual.zip,sep="")
    system(unzip.cmd)
    if (!file.exists(filt.qual.dir)) {
      pwarning("Unzip file ",filt.qual.zip," apparently failed.")
      return(NULL)
    }
  }
  files <- c(filt.qual.index,filt.qual.plot.base.quality,filt.qual.plot.seq.quality)
  names(files) <- c("index","base.quality","seq.quality")
  #print(files)
  return(files)
}

###########################
# load configuration file
pinfo("conf_file=",opt$conf.file)
#
conf <- load.configuration.file(opt$conf.file)
# set the report directory (overwrite toplevel.dir)

#
pinfo("Configuration file ",opt$conf.file," loaded.")

pdebug.save.state("irap_report_qc","p0")

qual_filt=conf.get.value(conf,"qual_filtering")
pinfo("Quality filtering:",qual_filt)
# QC filtering may be on or off
report.dir <- opt$rep_dir
report.dir <- paste(sub("/$","",report.dir),"/",sep="")
conf <- conf.set.value("report.dir",report.dir,conf)
pdebug.save.state("irap_report_qc","p1")
############################
# reads info
df <- raw.summary.dataframe(conf)

############################
# passed=number of reads
if (!conf.is.qc.enabled(conf)) {
    df$Passed <- df$reads
}
pinfo("Expanding table..")
etdf <- qc.expand.table(t(df),conf)
pdebug.save.state("irap_report_qc","p2")
############################
# save stats file
df2save <- t(etdf)
df2save[,"Lib"] <- rownames(df2save)
write.tsv(df2save,file=paste(report.dir,"qc.tsv",sep=""))
pinfo("Saved qc.tsv file")
qc.tsv.download.files <- c("qc.tsv")
names(qc.tsv.download.files) <- "TSV"
qc.tsv.download.html <- html.download.bar(qc.tsv.download.files)
pdebug.save.state("irap_report_qc","p3")
###########################
# fails here check image
table1.rows <- c("Passed","Unpaired","Ns","Contamination","Quality","Initial data (quality report)","Quality plots")
table1 <- quality.details.matrix(etdf,conf)
out.table1 <- table1[table1.rows,]
out.table1 <- gsub(conf.get.value(conf,"report.dir"),"",out.table1)
pdebug.save.state("irap_report_qc","p4")

library(brew)
####################################
out.dir <- report.dir
out.html.file <- paste(out.dir,"/qc.html",sep="")
pinfo("Generating ",out.dir,"/qc.html")
brew.wrapper(opt$html_template,out.html.file)
warnings()
pinfo("All done.")
q()

IRAP.DIR <- Sys.getenv(c("IRAP_DIR"))
if ( IRAP.DIR == "" ) {
  IRAP.DIR="/home/nf/Research/Projects/WIP/EREAP/ereap_install"
  Sys.setenv(IRAP_DIR=IRAP.DIR)
}

