#!/usr/bin/env Rscript
#; -*- mode: R;-*-
# =========================================================
#
# This is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License.
# If not, see <http://www.gnu.org/licenses/>.
#
#
# =========================================================

###############################################################
suppressPackageStartupMessages(library("optparse"))

IRAP.DIR <- Sys.getenv(c("IRAP_DIR"))
if ( IRAP.DIR == "" ) {
  cat("ERROR: environment variable IRAP_DIR is not set\n")
  q(status=1)
}
#
# specify our desired options in a list
#
source(paste(IRAP.DIR,"aux/R","irap_utils.R",sep="/"))
pdebug.enabled <- TRUE
#######################
usage <- "irap_single_lib_gen_tpm.R -l irap_lengths.Rdata --dir counts_dir [options]"

filenames <- c("dir","lengths_file")

option_list <- list(
  make_option(c("-d", "--dir"), type="character", dest="dir", default=NULL,help="Directory with the quantification files generated by irap_single_lib"),
  make_option(c("-l", "--lengths"), type="character", dest="lengths_file", default=NULL,help="File with the gene and transcript lengths generated by iRAP"),
  make_option(c("-f","--force"),action="store_true",dest="force",default=FALSE,help="Force the generation of the files when they already exist"),
  make_option(c("--debug"),action="store_true",dest="debug",default=FALSE,help="Debug mode")
)
mandatory <- c("dir","lengths_file")
#pinfo("saved")
opt <- myParseArgs(usage = usage, option_list=option_list,filenames.exist=filenames,mandatory=mandatory)

pdebug.enabled <- opt$debug

# Look for the gene level quantification file
#opt$dir="/tmp"
files.found <- system(paste("ls --color=never ",opt$dir,"/*genes.raw.*.tsv",sep=""),intern=TRUE)
force.gen <- opt$force
#print(force.gen)

cat("Gene level quantification: found ",length(files.found),"\n")
for ( f in as.vector(files.found) ) {
  cat("--->",f,"\n")
  tpm.file <- gsub(".raw.",".tpm.",f)
  tpm.file <- gsub(".tsv",".irap.tsv",tpm.file)
  if ( file.exists(tpm.file) && ! force.gen ) {
    cat("File ",tpm.file," already exists...skipping generation.\n")
  } else {
    cmd <- paste("irap_raw2metric --lengths ",opt$lengths," --tsv ",f," -f gene -m tpm -o ",tpm.file,sep="")
    if ( opt$debug ) { cat(cmd,"\n") }
    system(cmd,intern=TRUE)
    if ( file.exists(tpm.file) ) {
      cat("Generated ",tpm.file,"\n")
    } else
      stop("ERROR generating tpm.file\n")
  }
}
q(status=0)



#
pdebug.save.state("irap_raw2metric","p0")
lengths <- list()
gene.length <- NULL
trans.length <- NULL
exon.length <- NULL
# load TSV
# TODO: trap and report errors
table <- quant.load(opt$tsv_file)
# matrix may contain a single column with values
if ( is.vector(table) ) {
  names(table) <- ids
}

# Gene lib1 ....

# load lengths
load(opt$lengths_file)
if ( opt$feature=="gene" && ! exists("gene.length")) {
  perror("Unable to get the length of genes from ",opt$lengths_file)
  q(status=1)
}
if ( opt$feature=="exon" && ! exists("exon.length")) {
  perror("Unable to get the length of exons from ",opt$lengths_file)
  q(status=1)
}
pdebug("data loaded")

# load gtf if provided
gtf.table <- NULL
mass.labels <- NULL
feature.label <- paste(opt$feature,"_id",sep="")
if (!is.null(opt$gtf_file) ) {
  gtf.table <- load.gtf(opt$gtf_file,selected.attr=c(feature.label,"biotype"))
  pinfo("GTF file loaded: ",opt$gtf," ",nrow(gtf.table)," entries")

  if ( opt$mass_pconly) {
    mass.labels <- gtf.table[gtf.table$biotype=="protein_coding",feature.label]
  }
}

if (opt$feature=="exon" ) {
  #eids <- paste(exon.length$gene_id,exon.length$transcript_id,exon.length$exon_number,sep=".")
  #eids <- paste(exon.length$gene_id,exon.length$exon_number,sep=".")
  if ( sum( "exon_id" %in% colnames(exon.length)) > 0 ) {
    eids <- as.character(exon.length$exon_id)
  } else { 	     
    # backward compatibility
    eids <- paste(exon.length$gene_id,exon.length$exon_number,sep=".")
  }
  exon.length <- exon.length[,"elength"]
  names(exon.length) <- eids
}

lengths <- list(gene=gene.length,transcript=trans.length,exon=exon.length)
pdebug.save.state("irap_raw2metric","p1")
if ( opt$metric == "rpkm" ) {
  #(read count  * 1,000,000) / (total number of reads * kilobase of gene/transcript/exon)
  rpkm <- countstable2rpkms(table,lengths[[opt$feature]],mass.labels)
  if ( is.vector(rpkm) ) {
    rpkm <- data.frame(cbind(names(rpkm),rpkm),check.names=F)
    colnames(rpkm) <- append(capitalize(opt$feature),libnames)
  } else {
    rpkm <- data.frame(cbind(rownames(rpkm),rpkm),check.names=F)
    colnames(rpkm) <- append(capitalize(opt$feature),colnames(rpkm)[-1])
  }

  # save
  write.tsv(rpkm,file=opt$out)
  pinfo("Saved ",opt$out)
  q(status=0)
}

if ( opt$metric == "tpm" ) {
  tpm <- countstable2tpm(table,lengths[[opt$feature]])
  if ( is.vector(tpm) ) {
    tpm <- data.frame(cbind(names(tpm),tpm),check.names=F)
    colnames(tpm) <- append(capitalize(opt$feature),libnames)
  } else {
    tpm <- data.frame(cbind(rownames(tpm),tpm),check.names=F)
    colnames(tpm) <- append(capitalize(opt$feature),colnames(tpm)[-1])
  }

  # save
  write.tsv(tpm,file=opt$out)
  pinfo("Saved ",opt$out)
  q(status=0)
}

q(status=0)


